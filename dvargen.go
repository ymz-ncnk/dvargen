package dvargen

import (
	"bytes"
	"go/format"
	"os"
	template_mod "text/template"

	persistor_mod "github.com/ymz-ncnk/persistor"
)

const template = "" +
	"// Code generated by dvargen. DO NOT EDIT." +
	"\n\n" +
	"{{ $name := .Name }}" +
	"package {{.Package}}\n\n" +
	"var {{$name}} map[string]string\n" +
	"func init() {\n" +
	"	 {{$name}} = make(map[string]string)\n" +
	"  {{- range $fileName, $fileData := .Map }}\n" +
	"    {{$name}}[\"{{$fileName}}\"] = `{{$fileData}}`\n" +
	"  {{- end }}\n" +
	"}"

// FilenameExtension is an extension of the generated files.
const FilenameExtension = ".dvar.go"

// DefConf is the default configuration for DVarGen.
var DefConf = Conf{
	Path: "./",
	Perm: 0755,
}

// New creates a new DVarGen.
func New() DVarGen {
	return NewWith(persistor_mod.NewHarDrivePersistor())
}

// New creates a new configurable DVarGen.
func NewWith(persistor persistor_mod.Persistor) DVarGen {
	return DVarGen{persistor}
}

// DVarGen generates a map variable initialized with the contents of the
// directory.
type DVarGen struct {
	persistor persistor_mod.Persistor
}

// Generate generates a file with Golang source code, which initializes a
// map variable with directory content. Each key of this map is a file name,
// and value - file data.
// Uses DefConf.
func (dVarGen DVarGen) Generate(vDesc DVarDesc) error {
	return dVarGen.GenerateAs(vDesc, DefConf)
}

// GenerateAs performs like generate. With help of this method you can configure
// the generation process.
func (dVarGen DVarGen) GenerateAs(vDesc DVarDesc, conf Conf) error {
	m, err := dVarGen.makeMap(vDesc.Dir)
	if err != nil {
		return err
	}
	data, err := dVarGen.generate(vDesc, m)
	if err != nil {
		panic(err)
	}
	err = os.WriteFile(filepath(conf.Path, vDesc), data, conf.Perm)
	if err != nil {
		return err
	}
	return nil
}

func (dVarGen DVarGen) generate(vDesc DVarDesc, m map[string]string) ([]byte,
	error) {
	tmpl, err := template_mod.New("base").Parse(template)
	if err != nil {
		return nil, err
	}
	buf := bytes.NewBuffer(make([]byte, 0))
	err = tmpl.ExecuteTemplate(buf, "base", struct {
		Package string
		Name    string
		Map     map[string]string
	}{
		Package: vDesc.Package,
		Name:    vDesc.Varname,
		Map:     m,
	})
	if err != nil {
		return nil, err
	}
	return format.Source(buf.Bytes())
}

func (dVarGen DVarGen) makeMap(dir string) (map[string]string, error) {
	var (
		data     []byte
		filename string
		m        = make(map[string]string)
	)
	entries, err := os.ReadDir(dir)
	if err != nil {
		return nil, err
	}
	for i := 0; i < len(entries); i++ {
		if entries[i].IsDir() {
			return nil, ErrSubdir
		}
		filename = entries[i].Name()
		data, err = os.ReadFile(dir + string(os.PathSeparator) + filename)
		if err != nil {
			return nil, err
		}
		m[string(filename)] = string(data)
	}
	return m, nil
}

func filepath(path string, vDesc DVarDesc) string {
	return path + string(os.PathSeparator) + filename(vDesc)
}

func filename(vDesc DVarDesc) string {
	return vDesc.Varname + FilenameExtension
}
